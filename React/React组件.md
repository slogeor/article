





### 容器组件 Container Component

容器组件就是一个页面容器，用来放置当前页面的所有展示型组件。

* 只关心它们的运作方式
* 可能同时包含子级容器型组件和展示型组件，但大都不含 DOM 标签
* 为展示型组件或其他组件提供数据和方法
* 调用 action，并且将其作为展示组件的回调函数
* 维持许多变量状态，充当一个数据源
* 通常由高阶组件生成

### 展示组件 Presentational Component

展示组件是具体到某一个小的组件模块，比如一个按钮、一个卡片等。

* 只关心它们的样子
* 可能同时包含子级容器型组件和展示型组件，一般含 DOM 标签和自定义的样式
* 通常用 this.props.children 来包含其他组件
* 不依赖 app 其它组件
* 不会定义数据如何读取、如何改变
* 只通过 this.props 接受数据和回调函数
* 很少有自己的状态变量，即使有，也是 UI 的状态变量
* 一般是函数级组件，除非它们需要状态，lifecycle hooks，优化处理

### 这种方法的好处

* 分离关注，可以更好的理解 app 和 UI
* 更易复用，同样的展示型组件可以在不同的状态、数据源中使用
* 展示组件是 app 的调色板
* 这种方法会强迫你去解析布局相关的组件，强迫使用 this.props.children，而不是在不同容器中复制 jsx

### 引入容器组件的时机

当你意识到，有一些中间组件传递了过多的 props，有一些组件并不使用它们继承的 props 而只是将这些 props 传递给他们的子级，而且每次子级组件需要更多数据时，都需要重新调整或编写这些中间组件，那么，这个时候可以考虑引入容器组件。

这样做可以传递 props 和方法给末端的子级组件，而不必麻烦一些不相关的中间组件。

### 总结

* 展示和容器更好的分离，更好的理解应用程序和UI
* 重用性高，展示组件可以用于多个不同的 state 数据
* 展示组件就是你的调色板，可以把他们放到单独的页面
* 迫使你分离标签，达到更高的可复用性


### 无状态组组件

#### 概念

一个组件没有状态，那么组件的输出方法，将完全取决于 props 和 content，只要有相同的 props 和 content，那么组件的输出绝对相同。

```js
function HelloComponent(props, /* context */) {
  return <div>Hello {props.name}</div>
}
ReactDOM.render(<HelloComponent name="Sebastian" />, mountNode)
```

##### 优点

* 没有 this 关键字
* 语法更简洁
* 占内存更小(class 有 props、content 等诸多属性)，首次 render 性能更好
* 可以写成无副作用的函数
* 可扩展性更强(函数的 component、currying 等组合方式，比 class 的 extend 更灵活)

##### 缺点

* 没有生命周期函数，但可以通过高阶组件实现生命周期
* 没有this
* 不支持 ref
